70+88+89+92
65+69+73
sum(xc)
library(coin)
install.packages("coin")
library(coin)
?oneway test
?oneway_test
oneway_test(c(xc,xt)~as.factor(c(rep(0,10),rep(1,10))), distribution="exact")
sum(xc)
sum(xt)
as.factor(c(rep(0,10),rep(1,10))
)
length(xc)
length(xt)
sum(xt)-sum(xc)
18.8/2.1583
choosee(20,10)
choose(20,10)
sumall <- sum(xc)+sum(xt)
2*sum(xt)-sumall
sum(xt)-sum(xc)
cho <- combn(20, 10)
dim(cho)
cho[,1]
xall <- c(xc,xt)
xall[cho[,1]]
2*sum(xt)-sumall
obs_D <- 2*sum(xt)-sumall
cho <- combn(20, 10)
for (i in 1:ncol(cho)){
s <- s + (abs(2*sum(xall[cho[,i]])-sumall) >= obs_D)
}
s <- 0
cho <- combn(20, 10)
for (i in 1:ncol(cho)){
s <- s + (abs(2*sum(xall[cho[,i]])-sumall) >= obs_D)
}
s
s/ncol(cho)
ncol(cho)
?phyper
xc
mean(xt)-mean(xc)
var(xt)/length(xt)+var(xc)/length(xc)
mean(xt)-mean(xc)+c(-1,1)*qnorm(0.975)*(var(xt)/length(xt)+var(xc)/length(xc))
phyper(530, 708, 609, 820)
1-phyper(530, 708, 609, 820)
phyper(530, 708, 609, 820, lower.trial=FALSE)
phyper(530, 708, 609, 820, lower.tail=FALSE)
290+530
319+178
290+319
phyper(290, 820, 497, 609)
phyper(290, 820, 497, 609, lower.tail=FALSE)
phyper(290, 820, 497, 609)
2*phyper(290, 820, 497, 609)
nm <- 500
r <- 1000
set.seed(1)
H <- matrix(rnorm(nm*r), nm, r)
Gamma <- t(H)%*%H
Gdiag <- diag(diag(Gamma))
trueK <- rnorm(r)*rbinom(r, 1, 0.2)
g <- Gamma%*%trueK
Ginv <- diag(1/diag(Gamma))
Gdiagsqrtinv <- diag(1/sqrt(diag(Gamma)))
Proj <- function(A){A%*%solve(crossprod(A), t(A))}
Khat <- function(gamma) {solve(Gamma+gamma*Gdiag, g)}
gamma <- 0.13
Khat(gamma) /
c(((diag(r)-Ginv%*%t(H)%*%solve(gamma*diag(nm)+H%*%Ginv%*%t(H),H))/gamma) %*%Ginv%*%g)
f <- function(gamma){(diag(r)-Ginv%*%t(H)%*%solve(gamma*diag(nm)+H%*%Ginv%*%t(H),H))/gamma}
c(f(1e-10)) ## The limit matrix blows up
c(f(1e-10) %*% Ginv %*% g) ## The limit estimator blows up potentially or not??
max(abs(c(f(1e-10) %*% Ginv %*% g)))
max(abs(c(f(1e-20) %*% Ginv %*% g)))
max(abs(c(f(1e-3) %*% Ginv %*% g)))
trueK <- rnorm(r)
g <- Gamma%*%trueK
Ginv <- diag(1/diag(Gamma))
Gdiagsqrtinv <- diag(1/sqrt(diag(Gamma)))
Proj <- function(A){A%*%solve(crossprod(A), t(A))}
Khat <- function(gamma) {solve(Gamma+gamma*Gdiag, g)}
gamma <- 0.13
Khat(gamma) /
c(((diag(r)-Ginv%*%t(H)%*%solve(gamma*diag(nm)+H%*%Ginv%*%t(H),H))/gamma) %*%Ginv%*%g)
f <- function(gamma){(diag(r)-Ginv%*%t(H)%*%solve(gamma*diag(nm)+H%*%Ginv%*%t(H),H))/gamma}
c(f(1e-10)) ## The limit matrix blows up
c(f(1e-10) %*% Ginv %*% g) ## The limit estimator blows up potentially or not??
max(abs(c(f(1e-10) %*% Ginv %*% g)))
max(abs(c(f(1e-3) %*% Ginv %*% g)))
max(abs(c(f(1e-2) %*% Ginv %*% g)))
g <- rnorm(r)
Khat <- function(gamma) {solve(Gamma+gamma*Gdiag, g)}
gamma <- 0.13
Khat(gamma) /
c(((diag(r)-Ginv%*%t(H)%*%solve(gamma*diag(nm)+H%*%Ginv%*%t(H),H))/gamma) %*%Ginv%*%g)
max(abs(c(f(1e-3) %*% Ginv %*% g)))
max(abs(c(f(1e-10) %*% Ginv %*% g)))
max(abs(H%*%f(1e-10) - solve(H%*%Ginv%*%t(H), H))) ## However, has a limit when left-multiplied by H
max(abs(H%*%Khat(1e-10) - solve(H%*%Ginv%*%t(H), H%*%Ginv%*%g)))
est <- t(H)%*%solve(H%*%t(H), solve(H%*%Ginv%*%t(H), H%*%Ginv%*%g)) ## A potential estimator
cbind(est, trueK)
est_support <- sort(order(abs(est), decreasing=TRUE)[1:sum(trueK!=0)])
true_support <- which(trueK!=0)
length(intersect(est_support, true_support))
trueK <- rnorm(r)*rbinom(r, 1, 0.2)
g <- Gamma%*%trueK
Ginv <- diag(1/diag(Gamma))
Gdiagsqrtinv <- diag(1/sqrt(diag(Gamma)))
Proj <- function(A){A%*%solve(crossprod(A), t(A))}
Khat <- function(gamma) {solve(Gamma+gamma*Gdiag, g)}
gamma <- 0.13
Khat(gamma) /
c(((diag(r)-Ginv%*%t(H)%*%solve(gamma*diag(nm)+H%*%Ginv%*%t(H),H))/gamma) %*%Ginv%*%g)
f <- function(gamma){(diag(r)-Ginv%*%t(H)%*%solve(gamma*diag(nm)+H%*%Ginv%*%t(H),H))/gamma}
c(f(1e-10)) ## The limit matrix blows up
c(f(1e-10) %*% Ginv %*% g) ## The limit estimator may blow up (but not when g is in the column span of H/Gamma?)
est <- t(H)%*%solve(H%*%t(H), solve(H%*%Ginv%*%t(H), H%*%Ginv%*%g)) ## A potential estimator
cbind(est, trueK)
est_support <- sort(order(abs(est), decreasing=TRUE)[1:sum(trueK!=0)])
true_support <- which(trueK!=0)
length(intersect(est_support, true_support))
length(setdiff(est_support, true_support))
length(intersect(est_support, true_support))
sum(trueK!=0)
c(length(intersect(est_support, true_support))/sum(trueK!=0),
length(setdiff(est_support, true_support))/sum(trueK==0))
trueK <- rnorm(r)*rbinom(r, 1, 0.5)
g <- Gamma%*%trueK
Ginv <- diag(1/diag(Gamma))
Gdiagsqrtinv <- diag(1/sqrt(diag(Gamma)))
Proj <- function(A){A%*%solve(crossprod(A), t(A))}
Khat <- function(gamma) {solve(Gamma+gamma*Gdiag, g)}
gamma <- 0.13
Khat(gamma) /
c(((diag(r)-Ginv%*%t(H)%*%solve(gamma*diag(nm)+H%*%Ginv%*%t(H),H))/gamma) %*%Ginv%*%g)
f <- function(gamma){(diag(r)-Ginv%*%t(H)%*%solve(gamma*diag(nm)+H%*%Ginv%*%t(H),H))/gamma}
c(f(1e-10)) ## The limit matrix blows up
c(f(1e-10) %*% Ginv %*% g) ## The limit estimator may blow up (but not when g is in the column span of H/Gamma?)
est <- t(H)%*%solve(H%*%t(H), solve(H%*%Ginv%*%t(H), H%*%Ginv%*%g)) ## A potential estimator
cbind(est, trueK)
est_support <- sort(order(abs(est), decreasing=TRUE)[1:sum(trueK!=0)])
true_support <- which(trueK!=0)
c(length(intersect(est_support, true_support))/sum(trueK!=0),
length(setdiff(est_support, true_support))/sum(trueK==0)) ## TPR, FPR
tp_fp <- function(edges, true_edges, p){
return (c(length(intersect(true_edges, edges)) / length(true_edges),
length(setdiff(edges, true_edges)) / (p^2-p-length(true_edges))))
}
true_edges <- which(trueK!=0)
est
est  <- c(est)
est
ord <- order(abs(est), decreasing = T)
ord[1]
est[156]
ord[10]
est[680]
length(est) < max(true_edges)
max(true_edges)
length(est)
max(true_edges)
true_edges
ord
prd[1]
ord[1]
ord[1] %in% true_edges
sapply(1:length(est), function(i){ord[i] %in% true_edges})
tps <- sapply(1:length(est), function(i){ord[i] %in% true_edges})
fps <- 1-tps
tps
fps
cumsum(sapply(1:length(est), function(i){ord[i] %in% true_edges}))
length(cumsum(sapply(1:length(est), function(i){ord[i] %in% true_edges})))
1:1000-cumsum(sapply(1:length(est), function(i){ord[i] %in% true_edges}))-cumsum(1-tps)
tps <- cumsum(sapply(1:length(est), function(i){ord[i] %in% true_edges}))
fps <- 1:p-tps
fps <- 1:length(est)-tps
tps <- cumsum(sapply(1:(length(est)-1), function(i){ord[i] %in% true_edges}))/1:p
p <- length(est)
if (p < max(true_edges))
stop("Length of estimates must be at least as large as the max index in true_edges.")
if (p < 2)
stop("Length of estimates must be at least 2.")
remove(tp,fp)
tps <- cumsum(sapply(1:(p-1), function(i){ord[i] %in% true_edges}))/1:(p-1)
tps <- cumsum(sapply(1:(p-1), function(i){ord[i] %in% true_edges}))/1:(p-1)
fps <- (1:(p-1)-tps)/((p-1):1)
tps
fps
tps
p <- length(est)
tps <- cumsum(sapply(1:p, function(i){ord[i] %in% true_edges}))/length(true_edges)
fps <- (1:p-tps)/(p-length(true_edges))
tps
fps
tps
remove(tps,fps)
ord <- order(abs(est), decreasing = T)
tps <- cumsum(sapply(1:p, function(i){ord[i] %in% true_edges}))
fpr <- (1:p-tps)/(p-length(true_edges))
tps <- tps/length(true_edges)
remove(tps)
ord <- order(abs(est), decreasing = T)
tps <- cumsum(sapply(1:p, function(i){ord[i] %in% true_edges}))
fpr <- (1:p-tps)/(p-length(true_edges))
tpr <- tps/length(true_edges)
tpr
fpr
plot(fpr,tpr)
roc_curve <-  function(est, true_edges){
p <- length(est)
if (length(true_edges) >= p || length(true_edges) == 0) {
stop("Length of edges must be > 0 and < length(estimate).")
}
if (p < max(true_edges))
stop("Length of estimates must be at least as large as the max index in true_edges.")
if (p < 2)
stop("Length of estimates must be at least 2.")
ord <- order(abs(est), decreasing = T)
tps <- cumsum(sapply(1:p, function(i){ord[i] %in% true_edges}))
fpr <- (1:p-tps)/(p-length(true_edges))
tpr <- tps/length(true_edges)
return(cbind(tpr, fpr))
}
stop("aha", 2)
remove(p,tpr,tps,true_support, est)
remove(est_support, fpr)
roc_curve <-  function(est, true_edges){
## est: a vector of estimates of length equal to p, the number of variables
## true_edges: list of true edges, must be a proper subset of 1:p
## Plots the ROC curve given the estimates; assuming the estimated support
##   is the indices with the largest estimates in absolute value
p <- length(est)
if (length(true_edges) >= p || length(true_edges) == 0) {
stop("Length of edges must be > 0 and < length(estimate).")
}
if (p < max(true_edges))
stop("Length of estimates must be at least as large as the max index in true_edges.")
if (min(true_edges) < 1)
stop("True edges must be between 1 and ", p)
if (p < 2)
stop("Length of estimates must be at least 2.")
ord <- order(abs(est), decreasing = T)
tps <- cumsum(sapply(1:p, function(i){ord[i] %in% true_edges}))
fpr <- (1:p-tps)/(p-length(true_edges))
tpr <- tps/length(true_edges)
return(cbind(tpr, fpr))
}
est <- t(H)%*%solve(H%*%t(H), solve(H%*%Ginv%*%t(H), H%*%Ginv%*%g)) ## A potential estimator
roc_curve(est,  true_edges)
c(length(intersect(est_support, true_support))/sum(trueK!=0),
length(setdiff(est_support, true_support))/sum(trueK==0)) ## TPR, FPR
remove(true_edges)
true_support <- which(trueK!=0)
c(length(intersect(est_support, true_support))/sum(trueK!=0),
length(setdiff(est_support, true_support))/sum(trueK==0)) ## TPR, FPR
est <- t(H)%*%solve(H%*%t(H), solve(H%*%Ginv%*%t(H), H%*%Ginv%*%g)) ## A potential estimator
cbind(est, trueK)
est_support <- sort(order(abs(est), decreasing=TRUE)[1:sum(trueK!=0)])
true_support <- which(trueK!=0)
c(length(intersect(est_support, true_support))/sum(trueK!=0),
length(setdiff(est_support, true_support))/sum(trueK==0)) ## TPR, FPR
roc_curve(est, true_support)
c(length(intersect(est_support, true_support))/sum(trueK!=0),
length(setdiff(est_support, true_support))/sum(trueK==0)) ## TPR, FPR
roc_curve(est, true_support)[1,]
roc_curve(est, true_support)[2,]
roc_curve(est, true_support)[1000,]
res <- roc_curve(est, true_support)
roc_curve <-  function(est, true_edges){
## est: a vector of estimates of length equal to p, the number of variables
## true_edges: list of true edges, must be a proper subset of 1:p
## Plots the ROC curve given the estimates; assuming the estimated support
##   is the indices with the largest estimates in absolute value
p <- length(est)
if (length(true_edges) >= p || length(true_edges) == 0) {
stop("Length of edges must be > 0 and < length(estimate).")
}
if (p < max(true_edges))
stop("Length of estimates must be at least as large as the max index in true_edges.")
if (min(true_edges) < 1)
stop("True edges must be between 1 and ", p)
if (p < 2)
stop("Length of estimates must be at least 2.")
ord <- order(abs(est), decreasing = T)
tps <- c(0, cumsum(sapply(1:p, function(i){ord[i] %in% true_edges})))
fpr <- (0:p-tps)/(p-length(true_edges))
tpr <- tps/length(true_edges)
return (cbind(tpr, fpr))
}
sum(abs(res-roc_curve(est, true_support)[2:1001,]))
roc_curve <-  function(est, true_edges){
## est: a vector of estimates of length equal to p, the number of variables
## true_edges: list of true edges, must be a proper subset of 1:p
## Plots the ROC curve given the estimates; assuming the estimated support
##   is the indices with the largest estimates in absolute value
## Returns a (p+1)*2 matrix, where the first row is 0,0 and the last 1,1.
p <- length(est)
if (length(true_edges) >= p || length(true_edges) == 0) {
stop("Length of edges must be > 0 and < length(estimate).")
}
if (p < max(true_edges))
stop("Length of estimates must be at least as large as the max index in true_edges.")
if (min(true_edges) < 1)
stop("True edges must be between 1 and ", p)
if (p < 2)
stop("Length of estimates must be at least 2.")
ord <- order(abs(est), decreasing = T)
tps <- c(0, cumsum(sapply(1:p, function(i){ord[i] %in% true_edges})))
fpr <- (0:p-tps)/(p-length(true_edges))
tpr <- tps/length(true_edges)
return (cbind(tpr, fpr))
}
roc_curve(est,  true_support)
tp_fp <- roc_curve(est,  true_support)
plot(tp_fp[,2], tpfp_[,1])
tp_fp <- roc_curve(est,  true_support)
plot(tp_fp[,2], tpfp_[,1])
plot(tp_fp[,2], tp_fp[,1])
plot(tp_fp[,2], tp_fp[,1], type = "l")
points(c(0,1),c(0,1),lty=2)
points(c(0,1),c(0,1),type="l",lty=2)
nm <- 50
r <- 100
set.seed(1)
H <- matrix(rnorm(nm*r), nm, r)
Gamma <- t(H)%*%H
Gdiag <- diag(diag(Gamma))
trueK <- rnorm(r)*rbinom(r, 1, 0.2)
g <- Gamma%*%trueK
Ginv <- diag(1/diag(Gamma))
Gdiagsqrtinv <- diag(1/sqrt(diag(Gamma)))
Proj <- function(A){A%*%solve(crossprod(A), t(A))}
Khat <- function(gamma) {solve(Gamma+gamma*Gdiag, g)}
gamma <- 0.13
Khat(gamma) /
c(((diag(r)-Ginv%*%t(H)%*%solve(gamma*diag(nm)+H%*%Ginv%*%t(H),H))/gamma) %*%Ginv%*%g)
f <- function(gamma){(diag(r)-Ginv%*%t(H)%*%solve(gamma*diag(nm)+H%*%Ginv%*%t(H),H))/gamma}
c(f(1e-10)) ## The limit matrix blows up
c(f(1e-10) %*% Ginv %*% g) ## The limit estimator may blow up (but not when g is in the column span of H/Gamma?)
max(abs(H%*%f(1e-10) - solve(H%*%Ginv%*%t(H), H))) ## However, has a limit when left-multiplied by H
max(abs(H%*%Khat(1e-10) - solve(H%*%Ginv%*%t(H), H%*%Ginv%*%g)))
est <- t(H)%*%solve(H%*%t(H), solve(H%*%Ginv%*%t(H), H%*%Ginv%*%g)) ## A potential estimator
cbind(est, trueK)
est_support <- sort(order(abs(est), decreasing=TRUE)[1:sum(trueK!=0)])
true_support <- which(trueK!=0)
c(length(intersect(est_support, true_support))/sum(trueK!=0),
length(setdiff(est_support, true_support))/sum(trueK==0)) ## TPR, FPR
tp_fp <- function(edges, true_edges, p){
return (c(length(intersect(true_edges, edges)) / length(true_edges),
length(setdiff(edges, true_edges)) / (p^2-p-length(true_edges))))
}
roc_curve <-  function(est, true_edges){
## est: a vector of estimates of length equal to p, the number of variables
## true_edges: list of true edges, must be a proper subset of 1:p
## Plots the ROC curve given the estimates; assuming the estimated support
##   is the indices with the largest estimates in absolute value
## Returns a (p+1)*2 matrix, where the first row is 0,0 and the last 1,1.
p <- length(est)
if (length(true_edges) >= p || length(true_edges) == 0) {
stop("Length of edges must be > 0 and < length(estimate).")
}
if (p < max(true_edges))
stop("Length of estimates must be at least as large as the max index in true_edges.")
if (min(true_edges) < 1)
stop("True edges must be between 1 and ", p)
if (p < 2)
stop("Length of estimates must be at least 2.")
ord <- order(abs(est), decreasing = T)
tps <- c(0, cumsum(sapply(1:p, function(i){ord[i] %in% true_edges})))
fpr <- (0:p-tps)/(p-length(true_edges))
tpr <- tps/length(true_edges)
return (cbind(tpr, fpr))
}
tp_fp <- roc_curve(est,  true_support)
plot(tp_fp[,2], tp_fp[,1], type = "l")
points(c(0,1),c(0,1),type="l",lty=2)
trueK <- rnorm(r)*rbinom(r, 1, 0.5)
g <- Gamma%*%trueK
Ginv <- diag(1/diag(Gamma))
Gdiagsqrtinv <- diag(1/sqrt(diag(Gamma)))
Proj <- function(A){A%*%solve(crossprod(A), t(A))}
Khat <- function(gamma) {solve(Gamma+gamma*Gdiag, g)}
gamma <- 0.13
Khat(gamma) /
c(((diag(r)-Ginv%*%t(H)%*%solve(gamma*diag(nm)+H%*%Ginv%*%t(H),H))/gamma) %*%Ginv%*%g)
f <- function(gamma){(diag(r)-Ginv%*%t(H)%*%solve(gamma*diag(nm)+H%*%Ginv%*%t(H),H))/gamma}
c(f(1e-10)) ## The limit matrix blows up
c(f(1e-10) %*% Ginv %*% g) ## The limit estimator may blow up (but not when g is in the column span of H/Gamma?)
max(abs(H%*%f(1e-10) - solve(H%*%Ginv%*%t(H), H))) ## However, has a limit when left-multiplied by H
max(abs(H%*%Khat(1e-10) - solve(H%*%Ginv%*%t(H), H%*%Ginv%*%g)))
est <- t(H)%*%solve(H%*%t(H), solve(H%*%Ginv%*%t(H), H%*%Ginv%*%g)) ## A potential estimator
cbind(est, trueK)
est_support <- sort(order(abs(est), decreasing=TRUE)[1:sum(trueK!=0)])
true_support <- which(trueK!=0)
c(length(intersect(est_support, true_support))/sum(trueK!=0),
length(setdiff(est_support, true_support))/sum(trueK==0)) ## TPR, FPR
tp_fp <- roc_curve(est,  true_support)
plot(tp_fp[,2], tp_fp[,1], type = "l")
points(c(0,1),c(0,1),type="l",lty=2)
trueK <- rnorm(r)*rbinom(r, 1, 0.8)
g <- Gamma%*%trueK
Ginv <- diag(1/diag(Gamma))
Gdiagsqrtinv <- diag(1/sqrt(diag(Gamma)))
Proj <- function(A){A%*%solve(crossprod(A), t(A))}
Khat <- function(gamma) {solve(Gamma+gamma*Gdiag, g)}
gamma <- 0.13
f <- function(gamma){(diag(r)-Ginv%*%t(H)%*%solve(gamma*diag(nm)+H%*%Ginv%*%t(H),H))/gamma}
max(abs(H%*%Khat(1e-10) - solve(H%*%Ginv%*%t(H), H%*%Ginv%*%g)))
est <- t(H)%*%solve(H%*%t(H), solve(H%*%Ginv%*%t(H), H%*%Ginv%*%g)) ## A potential estimator
cbind(est, trueK)
est_support <- sort(order(abs(est), decreasing=TRUE)[1:sum(trueK!=0)])
true_support <- which(trueK!=0)
c(length(intersect(est_support, true_support))/sum(trueK!=0),
length(setdiff(est_support, true_support))/sum(trueK==0)) ## TPR, FPR
tp_fp <- roc_curve(est,  true_support)
plot(tp_fp[,2], tp_fp[,1], type = "l")
points(c(0,1),c(0,1),type="l",lty=2)
est <- f(1e-10) %*% Ginv %*% g ## If the limit of ridge does not blow up
tp_fp <- roc_curve(est,  true_support)
plot(tp_fp[,2], tp_fp[,1], type = "l")
points(c(0,1),c(0,1),type="l",lty=2)
est <- t(H)%*%solve(H%*%t(H), solve(H%*%Ginv%*%t(H), H%*%Ginv%*%g)) ## A potential estimator
tp_fp <- roc_curve(est,  true_support)
plot(tp_fp[,2], tp_fp[,1], type = "l")
points(c(0,1),c(0,1),type="l",lty=2)
nm <- 1000
r <- 2000
set.seed(1)
H <- matrix(rnorm(nm*r), nm, r)
Gamma <- t(H)%*%H
Gdiag <- diag(diag(Gamma))
trueK <- rnorm(r)*rbinom(r, 1, 0.8)
g <- Gamma%*%trueK
Ginv <- diag(1/diag(Gamma))
Gdiagsqrtinv <- diag(1/sqrt(diag(Gamma)))
Proj <- function(A){A%*%solve(crossprod(A), t(A))}
Khat <- function(gamma) {solve(Gamma+gamma*Gdiag, g)}
gamma <- 0.13
f <- function(gamma){(diag(r)-Ginv%*%t(H)%*%solve(gamma*diag(nm)+H%*%Ginv%*%t(H),H))/gamma}
max(abs(H%*%Khat(1e-10) - solve(H%*%Ginv%*%t(H), H%*%Ginv%*%g)))
est <- t(H)%*%solve(H%*%t(H), solve(H%*%Ginv%*%t(H), H%*%Ginv%*%g)) ## A potential estimator
cbind(est, trueK)
est_support <- sort(order(abs(est), decreasing=TRUE)[1:sum(trueK!=0)])
true_support <- which(trueK!=0)
c(length(intersect(est_support, true_support))/sum(trueK!=0),
length(setdiff(est_support, true_support))/sum(trueK==0)) ## TPR, FPR
tp_fp <- roc_curve(est,  true_support)
plot(tp_fp[,2], tp_fp[,1], type = "l")
points(c(0,1),c(0,1),type="l",lty=2)
trueK <- rnorm(r)*rbinom(r, 1, 0.2)
g <- Gamma%*%trueK
Ginv <- diag(1/diag(Gamma))
Gdiagsqrtinv <- diag(1/sqrt(diag(Gamma)))
Proj <- function(A){A%*%solve(crossprod(A), t(A))}
Khat <- function(gamma) {solve(Gamma+gamma*Gdiag, g)}
gamma <- 0.13
f <- function(gamma){(diag(r)-Ginv%*%t(H)%*%solve(gamma*diag(nm)+H%*%Ginv%*%t(H),H))/gamma}
est <- t(H)%*%solve(H%*%t(H), solve(H%*%Ginv%*%t(H), H%*%Ginv%*%g)) ## A potential estimator
cbind(est, trueK)
est_support <- sort(order(abs(est), decreasing=TRUE)[1:sum(trueK!=0)])
true_support <- which(trueK!=0)
c(length(intersect(est_support, true_support))/sum(trueK!=0),
length(setdiff(est_support, true_support))/sum(trueK==0)) ## TPR, FPR
tp_fp <- roc_curve(est,  true_support)
plot(tp_fp[,2], tp_fp[,1], type = "l")
points(c(0,1),c(0,1),type="l",lty=2)
library("knitr")
library("rmarkdown")
install.packages("rmarkdown")
library("rmarkdown")
rary("devtools")
library("devtools")
library("roxygen2")
install.packages("roxygen2")
setwd("~/Dropbox/Safe/Research/GSM/final/301011")
source("Score_init.R")
source("Score_ab_1011.R")
n <- 100
p <- 20
Theta <- numeric(p)
Phi <- -diag(p)
x <- rsqrt_gibbs_c(n, T, Theta, Phi, seed=1, burn_in=1000, every=1000, max_iter=1000)
x
x <- rsqrt_gibbs_c(n, T, Theta, Phi, seed=1, burn_in=1000, every=1000, max_iter=10000)
x
x <- rsqrt_gibbs_c(n, T, Theta, Phi, seed=1, burn_in=100, every=1000, max_iter=10000)
x <- rsqrt_gibbs_c(n, T, Theta, Phi, seed=1, burn_in=1000, every=100, max_iter=10000)
x <- rsqrt_gibbs_c(n, T, Theta, Phi, seed=1, burn_in=1000, every=100, max_iter=100000)
x <- rsqrt_gibbs_c(n, T, Theta, Phi, seed=1, burn_in=1000, every=1000, max_iter=100000)
x <- rsqrt_gibbs_c(n, T, Theta, Phi, seed=1, burn_in=10000, every=1000, max_iter=100000)
x <- rsqrt_gibbs_c(n, T, Theta, Phi, seed=1, burn_in=1000, every=10000, max_iter=100000)
setwd("~/Dropbox/Safe/Research/GSM/final/genscore/R")
source("genscore.R")
dyn.load("src/Score_gen.so")
dyn.load("../src/Score_gen.so")
dyn.load("../src/genscore.so")
x <- rexp_gamma_reject_R(n, T, Theta, Phi, seed=1, burn_in=1000, every=10000, max_iter=100000)
x <- rexp_gamma_reject_R(n, T, Theta, Phi, seed=1, burn_in=1000, thinning=10000, max_iter=100000)
x <- rexp_gamma_reject_R(n, T, Theta, -Phi, seed=1, burn_in=1000, thinning=10000, max_iter=100000)
x
setwd("~/Dropbox/Safe/Research/GSM/final/301011")
source("Score_init.R")
source("Score_ab_1011.R")
x <- rexp_gamma_reject_R(n, T, Theta, -Phi, seed=1, burn_in=1000, thinning=10000, max_iter=100000)
x <- rsqrt_gibbs_c(n, T, Theta, Phi, seed=1, burn_in=1000, every=10000, max_iter=100000)
x
dyn.load("src/Score_gen.so")
setwd("~/Dropbox/Safe/Research/GSM/final/genscore/R")
